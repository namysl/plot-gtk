# -*- coding: utf-8 -*-
"""mathfunctions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AktdvwgdL6FCGDJud5UmJelg01ugW4rw
"""

"""
Klasy potzebują podania parametrów np. dla liniowej a i b, zakresu x (x_min,x_max) i kroku dla x
Zwracana jest tablica ze złączonymi x i y a ich odczytanie objaśnione jest poniżej - patrz disclaimer
"""

class LinearFunction:
  def __init__(self,a,b,x_min,x_max,jump):
    self.a = a
    self.b = b
    self.x_min = x_min
    self.x_max = x_max
    self.jump = jump

  def wynik(self):
    self.lista = []
    x = self.x_min

    while(x<=self.x_max):
      y = self.a*x + self.b
      self.lista.append(x)
      self.lista.append(y)
      x+=self.jump
      if(self.jump==0):
        x=self.x_max+1

    return self.lista

    """
    Disclaimer: lista jest jednowymiarowa więc: 
                Parzyste indexy {0,2,4...} to wartości x
                Nieparzyste indexy {1,3,5...} to wartości y
    """

  def wypisz(self):
    for i in range(0,len(self.lista)-1,2):
      print("x: ",self.lista[i]," | y: ",self.lista[i+1])

class QuadraticFunction:
  def __init__(self,a,b,c,x_min,x_max,jump):
    self.a = a
    self.b = b
    self.c = c
    self.x_min = x_min
    self.x_max = x_max
    self.jump = jump

  def wynik(self):
    self.lista = []
    x = self.x_min

    while(x<=self.x_max):
      y = self.a * x**2 + self.b * x + self.c
      self.lista.append(x)
      self.lista.append(y)
      x+=self.jump
      if(self.jump==0):
        x=self.x_max+1

    return self.lista

  def wypisz(self):
    for i in range(0,len(self.lista)-1,2):
      print("x: ",self.lista[i]," | y: ",self.lista[i+1])

"""
Rozklad prawdopodobienstwa opisujacy liczbe sukcesow w podanych probach o danym prawdopodobienstwie sukcesu
Tutaj x to ilosc sukcesow a y to prawdopodobienstwa wystopienia danej liczby sukcesow w n-probach
"""
class BinomialDistribution:
  def __init__(self,n,p):
    self.n = n
    self.p = p

  def newton(self,n,k):
    iloczyn = 1
    for l in range(0,k):
      iloczyn*=(n-l)/(k-l)
    return iloczyn
  
  def wynik(self):
    self.lista = []
    x = 0
    while(x<=self.n):
      y = self.newton(self.n,x) * self.p**x * (1-self.p)**(self.n-x)
      self.lista.append(x)
      self.lista.append(y)
      x+=1

    return self.lista

  def wypisz(self):
    for i in range(0,len(self.lista)-1,2):
      print("x: ",self.lista[i]," | y: ",self.lista[i+1])

